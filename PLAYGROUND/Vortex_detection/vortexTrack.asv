clear variables
CameraNo = 1;
base = { ...
%     'D:\full\Processed_PIV_validation\90degree_400light_100hz_3000dt', ...
%     'D:\full\Processed_PIV_validation\90degree_250light_250hz_1000dt', ...
%     'D:\full\Processed_PIV_validation\60degree_400light_100hz_3000dt_reverse', ...
%     'D:\full\Processed_PIV_validation\60degree_250light_250hz_1000dt_reverse', ...
%     'D:\full\Processed_PIV_validation\60degree_400light_100hz_3000dt', ...
%     'D:\full\Processed_PIV_validation\60degree_250light_250hz_1000dt', ...
    'D:\full\Processed_PIV_validation\30degree_400light_100hz_3000dt_reverse', ...
    'D:\full\Processed_PIV_validation\30degree_250light_250hz_1000dt_reverse', ...
    'D:\full\Processed_PIV_validation\30degree_400light_100hz_3000dt', ...
    'D:\full\Processed_PIV_validation\30degree_250light_250hz_1000dt', ...
};
% samplingRate =[100,250,100,250,100,250,100,250,100,250,]; %hz 
samplingRate =[100,250,100,250,]; %hz 
min_expected_freq =0.3;
imageCount = 18000;
caseImages = 3600;
endpoint = '';
run = 5;
x_loc = [-100,-5];
close all


for i = 1:length(base)
        disp(base{i})
        dataloc = (fullfile(base{i}, 'CalibratedPIV', num2str(imageCount),['Cam', num2str(CameraNo)], 'Instantaneous',endpoint));
        % Load Co_ords.mat
        VelData = load(fullfile(dataloc, [num2str(sprintf('%05d.mat', 1))]));
        Co_ords = load(fullfile(dataloc, 'Co_ords.mat'));
        b_mask = VelData.piv_result(run).b_mask;
        row_means = mean(b_mask,2);
        first_row_index = find(row_means > 0.8, 1, 'first');
        % Initialize master arrays as empty arrays with 2 columns.
        vortexCentersX_all = [];
        vortexCentersY_all = [];
        rotation_all = [];
        v_flux_all = [];
        deltaStar_all=[];
        vortexSize_all=[];
        momentumThickness_all =[];




    for imNo = 1: imageCount
        dataloc = (fullfile(base{i}, 'CalibratedPIV', num2str(imageCount),['Cam', num2str(CameraNo)], 'Instantaneous',endpoint));
        % Load Co_ords.mat
        VelData = load(fullfile(dataloc, [num2str(sprintf('%05d.mat', imNo))]));
        y = Co_ords.Co_ords(run).y;
        x = Co_ords.Co_ords(run).x;
        u = VelData.piv_result(run).ux;
        v = VelData.piv_result(run).uy;

        %% delta star calculation
        % Select only y > 0 (upper boundary layer)
        positive_y_indices = y(:,1) > 0;

        % Define the freestream velocity (99th percentile of the x-velocity)
        percentile_speed = prctile(u(positive_y_indices, :), 99, 'all');

        deltaStar_temp = zeros(1, length(x_loc));

        momentumThickness_temp = zeros(1, length(x_loc));

        for j = 1:length(x_loc)
            % Find the closest x-column to the desired x-location
            [~, x_index] = min(abs(x(1,:) - x_loc(j)));
            
            % Define a range of columns around this x-location to smooth the profile
            col_range = max(1, x_index-3) : min(size(x, 2), x_index+3);
            
            % Extract and normalize the velocity profile (for y > 0)
            velocity_profile = mean(u(positive_y_indices, col_range), 2) / percentile_speed;
            
            % Compute the displacement thickness δ* using trapezoidal integration
            deltaStar_temp(j) = trapz(flipud(y(positive_y_indices, 1)), (1 - velocity_profile));
            
            % Compute the momentum thickness θ using trapezoidal integration
            momentumThickness_temp(j) = trapz(flipud(y(positive_y_indices, 1)), velocity_profile .* (1 - velocity_profile));
        end
        
        % Append the calculated values as a new row to their respective arrays
        deltaStar_all = [deltaStar_all; deltaStar_temp];           % [mm]
        momentumThickness_all = [momentumThickness_all; momentumThickness_temp]; 


        %% gamma field
        
       
        gammaField = gamma1(x, y, u, v, 10);
%         tempgamma = gamma2(x,y,u,v,10);
%         tempgamma(b_mask) =0;
        gammaField(b_mask) = 0;
        gammaField(1:20,:)=0;

%         % Compute the absolute value of v
%         abs_u = abs(u);
%         
%         % Set the values where b_mask is true to NaN, so they won’t be included in the average.
%         abs_u(b_mask) = NaN;
%         
%         % Compute the row-wise average of abs(v) for valid (b_mask == false) pixels
%         % Using 'omitnan' ensures that NaN values are ignored.
%         row_mean_abs_u = mean(abs_u, 2, 'omitnan');
%         
%         % Create a logical mask for rows where the average is above 0.01
%         valid_rows = (row_mean_abs_u > 0.015);
%         
%         % Expand to 2D to match gammaField dimensions
%         valid_mask_2D = repmat(valid_rows, 1, size(v, 2));
%         
%         % Zero out gammaField in rows that do not meet the criterion
%         gammaField(~valid_mask_2D) = 0;

        
      
        % Threshold for vortex detection
        threshold = 0.5;
        
        % Identify Positive (Counterclockwise) Vortex Centers
        BW_pos = imregionalmax(gammaField); % Local maxima
        BW_pos = BW_pos & (gammaField > threshold); % Keep only positive vortices
        
        
        % Identify Negative (Clockwise) Vortex Centers
        BW_neg = imregionalmin(gammaField); % Local minima
        BW_neg = BW_neg & (gammaField < -threshold); % Keep only negative vortices
        
        % Extract vortex center coordinates and gamma values
        vortexCentersX_pos = x(BW_pos)';
        vortexCentersY_pos = y(BW_pos)';
        gamma2Values_pos = gammaField(BW_pos)';
        
        vortexCentersX_neg = x(BW_neg)';
        vortexCentersY_neg = y(BW_neg)';
        gamma2Values_neg = gammaField(BW_neg)';
        
        % Handle edge cases: Ensure we get exactly one positive and one negative vortex
        if isempty(vortexCentersX_pos) % No positive vortex found
            vortexPosX = NaN;
            vortexPosY = NaN;
        else
            [~, idx_max_pos] = max(gamma2Values_pos); % Strongest positive vortex
            vortexPosX = vortexCentersX_pos(idx_max_pos);
            vortexPosY = vortexCentersY_pos(idx_max_pos);
        end
        
        if isempty(vortexCentersX_neg) % No negative vortex found
            vortexNegX = NaN;
            vortexNegY = NaN;
        else
            [~, idx_max_neg] = min(gamma2Values_neg); % Strongest negative vortex
            vortexNegX = vortexCentersX_neg(idx_max_neg);
            vortexNegY = vortexCentersY_neg(idx_max_neg);
        end
        
        % Vortex centres ' maximum value' 
        vortexCentersX = [vortexPosX, vortexNegX];
        vortexCentersY = [vortexPosY, vortexNegY];
        

        
        % Initialize outputs
        xCentroidReal = [];
        yCentroidReal = [];
        vortexSize = [];
        rotationRates = [];
        % at this point we only have a rough idea of the centre of the
        % vortex

        for k = 1:2
            % Skip if invalid or missing
           if isnan(vortexCentersX(k))
                % Assign NaN only to the missing vortex, but continue processing the other
                xCentroidReal(k) = NaN;
                yCentroidReal(k) = NaN;
                rotationRates(k) = NaN;
                vortexSize(k) = NaN;
                continue; % Move to the next vortex without breaking the loop
            end

            
            % 1) Find the closest grid point for this vortex center
            [~, centerIdx] = min((x(:) - vortexCentersX(k)).^2 + (y(:) - vortexCentersY(k)).^2);
            peakGamma = gammaField(centerIdx); 
            contourLevel = abs(0.5* peakGamma); % 2/pi 

            % 2) Create a binary mask for this vortex region
            regionMask = (abs(gammaField) >= contourLevel) & (abs(gammaField) >= 0.42);

            regionMask = bwareaopen(regionMask, 8); % Remove small fragmented components        
            
            CC = bwconncomp(regionMask); % Get connected components
            numPixels = cellfun(@numel, CC.PixelIdxList); % Count number of pixels in each component
            
            % Find the indices of the two largest components
            [~, sortedIndices] = maxk(numPixels, 2); 
            
            % Create a new binary mask with only the two largest components
            newRegionMask = false(size(regionMask));
            for L = 1:length(sortedIndices)
                newRegionMask(CC.PixelIdxList{sortedIndices(L)}) = true;
            end
            
            % Multiply by gammaField to retain original values
            regionMask = newRegionMask .* gammaField;


            
            % 3) Identify which connected component contains the vortex
            % center for this index
            CC = bwconncomp(regionMask);
            componentIndex = [];
            for compNum = 1:CC.NumObjects
                if ismember(centerIdx, CC.PixelIdxList{compNum})
                    componentIndex = compNum;
                    break;
                end
            end
            if isempty(componentIndex)
                xCentroidReal(k) = NaN;
                yCentroidReal(k) = NaN;
                rotationRates(k) = NaN;
                vortexSize(k) = NaN;
                continue
            end
             % 4) Create an isolated mask for just this vortex of interest
            isolatedMask = zeros(size(regionMask));  % Initialize empty mask
            isolatedMask_weights = isolatedMask;
            vorticityMask = zeros(size(regionMask));
            pixelIndices = CC.PixelIdxList{componentIndex};  % Get the pixel indices for the identified component
            
            


            isolatedMask_weights(pixelIndices) = gammaField(pixelIndices);  % Keep only the identified component
            isolatedMask = abs(isolatedMask_weights) >0;
            [dx,~] = gradient(x);
            [~,dy] = gradient(y);
            dy = -dy;  % because y was flipped
            pixel_area = (dx(1,1) * dy(1,1))*1*(10^-6);
            vortexSize = [vortexSize, sum(isolatedMask(:)) * pixel_area];  % Calculate the vortex size
       
              
            % 5) Calculate the centroid
            regionStats = regionprops(isolatedMask, isolatedMask_weights, 'WeightedCentroid');
            ctd = regionStats.WeightedCentroid;
            % Extract the fractional part and integer part of the centroid
            rowLower = floor(ctd(2));   % The integer part of the row (y-coordinate)
            colLower = floor(ctd(1));   % The integer part of the column (x-coordinate)
            
            rowUpper = rowLower + 1;    % The next row (y-coordinate)
            colUpper = colLower + 1;    % The next column (x-coordinate)
            
            fractionalRow = ctd(2) - rowLower;  % The fractional part of the row
            fractionalCol = ctd(1) - colLower;  % The fractional part of the column
            
            % Interpolate the real-world coordinates (x and y) at the centroid location
            % Assuming x and y are the real-world calibrated meshgrids
            
            % Interpolate x-coordinate
            xCentroid = x(rowLower, colLower) + fractionalRow * (x(rowUpper, colLower) - x(rowLower, colLower)) + ...
                            fractionalCol * (x(rowLower, colUpper) - x(rowLower, colLower)) + ...
                            fractionalRow * fractionalCol * (x(rowUpper, colUpper) - x(rowUpper, colLower) - x(rowLower, colUpper) + x(rowLower, colLower));
            
            % Interpolate y-coordinate
            yCentroid = y(rowLower, colLower) + fractionalRow * (y(rowUpper, colLower) - y(rowLower, colLower)) + ...
                            fractionalCol * (y(rowLower, colUpper) - y(rowLower, colLower)) + ...
                            fractionalRow * fractionalCol * (y(rowUpper, colUpper) - y(rowUpper, colLower) - y(rowLower, colUpper) + y(rowLower, colLower));
            
            xCentroidReal = [xCentroidReal, xCentroid];
            yCentroidReal = [yCentroidReal, yCentroid];

            boundaries = bwboundaries(isolatedMask);
            
            boundaryIdx = boundaries{1};
            distances = nan(length(boundaryIdx), 1);
            vtan = nan(length(boundaryIdx), 1);
            theta = nan(length(boundaryIdx), 1);

            for idx = 1:length(boundaryIdx)
                % Get the row and column indices of the boundary pixel
                rIdx = boundaryIdx(idx, 1);
                cIdx = boundaryIdx(idx, 2);
                
                % Get physical coordinates for pixel (assumed from calibrated meshgrid)
                xp = x(rIdx, cIdx);
                yp = y(rIdx, cIdx);
                
                % Compute radial vector components relative to vortex center
                dx_val = xp - vortexCentersX(1, k);
                dy_val = yp - vortexCentersY(1, k);
                theta(idx) = atan2(dy_val, dx_val);    
                r = sqrt(dx_val^2 + dy_val^2);
                distances(idx) = r;
                
                if r == 0
                    continue;
                end
            
                % Get the velocity components at the boundary pixel
                up = u(rIdx, cIdx);
                vp = v(rIdx, cIdx);
                
                % Tangential velocity component
                vtan(idx) = -up * sin(theta(idx)) + vp * cos(theta(idx));
            end
            
            % Compute the angular velocity (assuming distances are in meters and converting to rad/s)
            omega = vtan ./ (distances * 10^-3); % [rad/s]
            
            % Store the mean rotation rate (converted to revolutions per second)
            rotationRates = [rotationRates, mean(omega / (2 * pi), 'omitnan')]; % [rev/s]         
                        


            
        end

        vortexCentersX_all = [vortexCentersX_all; xCentroidReal];
        vortexCentersY_all = [vortexCentersY_all; yCentroidReal];
        vortexSize_all = [vortexSize_all; vortexSize];
        rotation_all = [rotation_all; rotationRates];


        % Integrate the v component flux across specific rows
        % Identify opening columns for first_row_index
        openCols = find(~b_mask(first_row_index, :));
        if ~isempty(openCols)
            c_min = min(openCols);
            c_max = max(openCols);
        else
            c_min = NaN; c_max = NaN;
        end

        % For two rows above, use the same c_min:d_max
        % For rows below, recalculate opening each time
        rowOffsets = [-5, -4, -3 ,-2 -1 0 1 2 3,4,5];
        fluxes = nan(1, numel(rowOffsets));
        for idx = 1:numel(rowOffsets)
            r = first_row_index + rowOffsets(idx);
            if r >= 1 && r <= size(v,1)
                if rowOffsets(idx) < 0
                    % Use the same c_min, c_max as the reference row
                    if ~isnan(c_min)
                        fluxes(idx) = trapz(x(r, c_min:c_max), v(r, c_min:c_max));
                    end
                else
                    % Recalculate opening for each row below
                    newOpenCols = find(~b_mask(r, :));
                    if ~isempty(newOpenCols)
                        c_minBelow = min(newOpenCols);
                        c_maxBelow = max(newOpenCols);
                        fluxes(idx) = trapz(x(r, c_minBelow:c_maxBelow), v(r, c_minBelow:c_maxBelow));
                    end
                end
            end
        end
        v_flux_all = [v_flux_all; fluxes];
        

      
        

        if mod(imNo, 1000) == 0
            disp(imNo)
        
            figure(1);
            subplot(2,2,1);
            contourf(x, y, u, 20); colorbar;
            title(['u-velocity at t = ', num2str(imNo)]); xlabel('x'); ylabel('y');
            
            subplot(2,2,2);
            contourf(x, y, v, 20); colorbar;
            title(['v-velocity at t = ', num2str(imNo)]); xlabel('x'); ylabel('y');
           
            subplot(2,2,3)
            imagesc(regionMask)
            title(['vortex detected regions at t = ', num2str(imNo)])
            
            
            subplot(2,2,4);
            contourf(x, y, gammaField, 20, 'LineColor', 'none'); colorbar; caxis([-1 1]); hold on;
%             plot(vortexCentersX, vortexCentersY, 'ko', 'MarkerSize', 10, 'LineWidth', 2);
            title(['gamma1 Field and Detected Vortex Centres at t = ', num2str(imNo)]);
            xlabel('x'); ylabel('y');
            
          

                
                % Plot the real-world centroid
            plot(xCentroidReal, yCentroidReal, 'bx', 'MarkerSize', 10, 'LineWidth', 2);


%             figure;
%             imagesc(regionMask)

            set(gcf, 'Units', 'Normalized', 'OuterPosition', [0, 0.04, 1, 0.96]);

            saveas(figure(1), fullfile(base{i}, 'Statistics', num2str(imageCount), ['Cam', num2str(CameraNo)], 'Instantaneous', 'Calibrated', sprintf('vortex_break_down_%05d.fig', imNo)));
            saveas(figure(1), fullfile(base{i}, 'Statistics', num2str(imageCount), ['Cam', num2str(CameraNo)], 'Instantaneous', 'Calibrated', sprintf('vortex_break_down_%05d.jpg', imNo)));
            close(figure(1));
        end
        
    end


% 
    % Define parameters
    dt = 1 / samplingRate(i);
    segment_length = ceil(samplingRate(i) / 0.3);
    segment_length = min(caseImages, segment_length);
    overlap = segment_length / 2;
    nfft = 2^nextpow2(segment_length);
    frequencies = struct();
    
    % Define save directory
    save_dir = fullfile(base{i}, 'Statistics', num2str(imageCount), ['Cam', num2str(CameraNo)], 'Instantaneous', 'Calibrated');
    
    save_path = fullfile(save_dir, 'cavity_stats.mat');
    



    
    % Process X & Y Locations
    for k = 1:size(vortexCentersY_all, 2)
        frequencies.vortexCenterY(k) = process_and_plot(vortexCentersY_all(:, k), ['vortexCenterY_' num2str(k)], save_dir, samplingRate(i), segment_length, overlap, nfft);
        frequencies.vortexCenterX(k) = process_and_plot(vortexCentersX_all(:, k), ['vortexCenterX_' num2str(k)], save_dir, samplingRate(i), segment_length, overlap, nfft);
        frequencies.rotation(k) = process_and_plot(rotation_all(:,k), ['rotationRate' num2str(k)], save_dir, samplingRate(i), segment_length, overlap, nfft);
        frequencies.vortexSize(k) = process_and_plot(vortexSize_all(:,k), ['rotationRate' num2str(k)], save_dir, samplingRate(i), segment_length, overlap, nfft);
    
    end
    
    for k = 1:size(x_loc,2)
        frequencies.deltaStar(k) = process_and_plot(deltaStar_all(:,k), ['delta_star' num2str(k)], save_dir, samplingRate(i), segment_length, overlap, nfft);
    end
    
    
    for k = 1:size(v_flux_all,2)
        frequencies.vflux(k) = process_and_plot(v_flux_all(:,k), ['vflux' num2str(k)], save_dir, samplingRate(i), segment_length, overlap, nfft);
    
    
    end
    % Save variables
    save(save_path, 'vortexCentersX_all', 'vortexCentersY_all', 'rotation_all', ...
        'v_flux_all', 'deltaStar_all', 'vortexSize_all', 'frequencies', 'momentumThickness_all');


end

function frequencies = process_and_plot(data, dataLabel, save_dir, samplingRate, segment_length, overlap, nfft)
    % Function to compute and plot time series, autocorrelation, and PSD
    % data: The time series data to be processed
    % dataLabel: The name used in plot titles and filenames
    % save_dir: Directory to save the plots
    % samplingRate, segment_length, overlap, nfft: Parameters for PSD computation

    % Create time series plot
    nanRatio = sum(isnan(data)) / numel(data);
    if nanRatio > 0.3
        disp(['Too many NaNs for ' dataLabel,' NaN fraction: ' [num2str(nanRatio)]]);
        return
    end
    
    figure;
    set(gcf, 'Units', 'Normalized', 'OuterPosition', [0, 0.04, 1, 0.96]);
    plot(1:length(data), data, 'b-o', 'LineWidth', 1.5, 'MarkerSize', 6);
    grid on;
    title([dataLabel, ' vs Time']);
    xlabel('Time Step');
    ylabel(dataLabel);
    xlim([0, 500]);

    % Save figure
    saveas(gcf, fullfile(save_dir, [dataLabel, '.fig']));
    saveas(gcf, fullfile(save_dir, [dataLabel, '.jpg']));
    close(gcf);

    xc_length = 2 * 3600 - 1;
    
    % Initialize an accumulator for the autocorrelation and a counter.
    local_ac_sum = zeros(1, xc_length);
    
    for seg = 1:5
        % Define index range for this segment.
        idx_start = (seg - 1) * 3600 + 1;
        idx_end   = seg * 3600;
        
        % Extract the segment from the data.
        seg_data = data(idx_start:idx_end);
        
        % Preprocess the segment:
        % 1. Fill missing data.
        % 2. Remove the mean.
        seg_data = fillmissing(seg_data, 'linear');
        seg_data = seg_data - mean(seg_data);
        
        % Compute autocorrelation for this segment.
        ac_seg = xcorr(seg_data, 'unbiased');
        
        % Accumulate the autocorrelation.
        local_ac_sum = local_ac_sum + ac_seg;
    end
    
    % Average the autocorrelation over all segments.
    autocorr_data = local_ac_sum / 5;

    % Plot autocorrelation
    figure;
    set(gcf, 'Units', 'Normalized', 'OuterPosition', [0, 0.04, 1, 0.96]);
    plot(autocorr_data);
    title(['Autocorrelation of ', dataLabel]);
    xlabel('Lag');
    ylabel('Autocorrelation');
    grid on;

    % Save autocorrelation plot
    saveas(gcf, fullfile(save_dir, ['Autocorrelation_', dataLabel, '.fig']));
    saveas(gcf, fullfile(save_dir, ['Autocorrelation_', dataLabel, '.jpg']));
    close(gcf);

    % Compute Power Spectral Density (PSD)
    
    [pxx, f] = pwelch(data, hamming(segment_length), overlap, nfft, samplingRate);

    % Plot PSD
    figure;
    set(gcf, 'Units', 'Normalized', 'OuterPosition', [0, 0.04, 1, 0.96]);
    plot(f, 10 * log10(pxx), 'LineWidth', 1.5);
    xlabel('Frequency (Hz)');
    ylabel('Power/Frequency (dB/Hz)');
    title(['Power Spectral Density (PSD) of ', dataLabel]);
    grid on;
    xlim([0, 5]);

    % Save PSD plot
    saveas(gcf, fullfile(save_dir, ['PSD_', dataLabel, '.fig']));
    saveas(gcf, fullfile(save_dir, ['PSD_', dataLabel, '.jpg']));
    close(gcf);

    % Find the frequency corresponding to the maximum energy
    [~, idx] = max(pxx);
    frequencies = f(idx); % Frequency at maximum power
end